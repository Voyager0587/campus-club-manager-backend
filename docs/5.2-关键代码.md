# 5.2 关键代码

## 6.2.1 用户登录与Sa-Token权限验证

代码位置

- **文件**: `UserServiceImpl.java:72-100`
- **功能**: 实现用户登录、密码验证和Token生成

```java
/**
 * 用户登录
 * 文件位置: UserServiceImpl.java:72-100
 */
@Override
public LoginResponse login(LoginRequest request) {
    // 查询用户
    LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(User::getUsername, request.getUsername());
    User user = this.getOne(queryWrapper);

    if (user == null) {
        throw new BusinessException("用户名或密码错误");
    }

    // 验证密码
    if (!user.getPassword().equals(encryptPassword(request.getPassword()))) {
        throw new BusinessException("用户名或密码错误");
    }

    // 检查账户状态
    if (user.getStatus() == 0) {
        throw new BusinessException("账户已被禁用");
    }

    // 登录成功,生成Token
    StpUtil.login(user.getId());
    String token = StpUtil.getTokenValue();

    // 构造用户信息
    UserInfoVO userInfo = convertToUserInfoVO(user);

    return new LoginResponse(token, userInfo);
}
```

**技术要点**:
1. **密码加密**: 使用MD5+盐值方式加密密码,确保密码安全存储
2. **Sa-Token集成**: 调用`StpUtil.login(userId)`生成会话,自动管理Token
3. **异常处理**: 通过BusinessException统一处理业务异常
4. **状态验证**: 多层验证确保只有合法账户可以登录

### 6.2.2 社团申请审核与事务管理

代码位置

- **文件**: `ClubServiceImpl.java:136-178`
- **功能**: 管理员审核社团申请,通过则自动添加为成员

```java
/**
 * 审核社团申请(管理员)
 * 文件位置: ClubServiceImpl.java:136-178
 */
@Override
@Transactional(rollbackFor = Exception.class)
public void reviewApplication(ReviewApplicationRequest request) {
    Long reviewerId = StpUtil.getLoginIdAsLong();

    // 查询申请记录
    ClubApplication application = clubApplicationMapper.selectById(request.getApplicationId());
    if (application == null) {
        throw new BusinessException(10204, "申请记录不存在");
    }

    // 检查申请状态
    if (application.getStatus() != ApplicationStatus.PENDING) {
        throw new BusinessException(10205, "该申请已被处理");
    }

    // 验证审核结果
    ApplicationStatus status;
    try {
        status = ApplicationStatus.fromCode(request.getStatus());
    } catch (IllegalArgumentException e) {
        throw new BusinessException(10001, "审核结果不合法");
    }

    if (status != ApplicationStatus.APPROVED && status != ApplicationStatus.REJECTED) {
        throw new BusinessException(10001, "审核结果只能是approved或rejected");
    }

    // 更新申请状态
    application.setStatus(status);
    application.setReviewNote(request.getReviewNote());
    application.setReviewTime(LocalDateTime.now());
    application.setReviewerId(reviewerId);
    clubApplicationMapper.updateById(application);

    // 如果审核通过,将用户添加为社团成员
    if (status == ApplicationStatus.APPROVED) {
        ClubMember member = new ClubMember();
        member.setClubId(application.getClubId());
        member.setUserId(application.getUserId());
        member.setRole(MemberRole.MEMBER);
        member.setJoinTime(LocalDateTime.now());
        clubMemberMapper.insert(member);
    }
}
```

**技术要点**:
1. **声明式事务**: 使用`@Transactional`注解确保审核和添加成员操作的原子性
2. **状态机模式**: 通过ApplicationStatus枚举管理申请状态流转
3. **业务规则验证**: 只有PENDING状态的申请才能被审核
4. **关联操作**: 审核通过后自动创建club_member记录,实现业务闭环



### 6.2.3 活动报名与并发控制

代码位置

- **文件**: `ActivityServiceImpl.java:591-652`
- **功能**: 学生报名活动,包含人数限制、时间验证等业务逻辑

```java
/**
 * 报名活动
 * 文件位置: ActivityServiceImpl.java:591-652
 */
@Override
@Transactional(rollbackFor = Exception.class)
public void signupActivity(Long activityId) {
    Long userId = StpUtil.getLoginIdAsLong();

    // 验证活动是否存在
    Activity activity = this.getById(activityId);
    if (activity == null) {
        throw new BusinessException(20101, "活动不存在");
    }

    // 验证活动状态
    if (activity.getStatus() != ActivityStatus.PUBLISHED) {
        throw new BusinessException(20105, "该活动不可报名");
    }

    // 验证报名时间
    LocalDateTime now = LocalDateTime.now();
    if (activity.getSignupStartTime() != null && now.isBefore(activity.getSignupStartTime())) {
        throw new BusinessException(20105, "报名尚未开始");
    }
    if (activity.getSignupEndTime() != null && now.isAfter(activity.getSignupEndTime())) {
        throw new BusinessException(20105, "报名已截止");
    }

    // 检查是否已报名
    LambdaQueryWrapper<ActivitySignup> wrapper = new LambdaQueryWrapper<>();
    wrapper.eq(ActivitySignup::getActivityId, activityId)
            .eq(ActivitySignup::getUserId, userId);
    ActivitySignup existingSignup = activitySignupMapper.selectOne(wrapper);

    if (existingSignup != null) {
        if (existingSignup.getStatus() == SignupStatus.REGISTERED) {
            throw new BusinessException(20106, "您已报名该活动");
        } else if (existingSignup.getStatus() == SignupStatus.CANCELLED) {
            // 重新报名
            existingSignup.setStatus(SignupStatus.REGISTERED);
            existingSignup.setSignupTime(LocalDateTime.now());
            activitySignupMapper.updateById(existingSignup);

            // 更新活动报名人数
            activity.setCurrentMembers(activity.getCurrentMembers() + 1);
            this.updateById(activity);
            return;
        }
    }

    // 检查人数限制
    if (activity.getMaxMembers() != null && activity.getCurrentMembers() >= activity.getMaxMembers()) {
        throw new BusinessException(20105, "活动报名人数已满");
    }

    // 创建报名记录
    ActivitySignup signup = new ActivitySignup();
    signup.setActivityId(activityId);
    signup.setUserId(userId);
    signup.setStatus(SignupStatus.REGISTERED);
    signup.setSignupTime(LocalDateTime.now());
    activitySignupMapper.insert(signup);

    // 更新活动报名人数
    activity.setCurrentMembers(activity.getCurrentMembers() + 1);
    this.updateById(activity);
}
```

**技术要点**:
1. **多重验证**: 活动状态、报名时间、人数限制等多层验证确保业务规则
2. **幂等性处理**: 检查已报名状态,防止重复报名
3. **事务保证**: 报名记录插入和人数更新在同一事务中,保证数据一致性
4. **冗余字段优化**: current_members字段避免频繁COUNT查询,提升性能

### 6.2.4 活动签到批量操作

代码位置

- **文件**: `ActivityServiceImpl.java:202-236`
- **功能**: 社团负责人批量为报名用户签到或标记缺席

```java
/**
 * 活动签到/标记缺席(社团管理员)
 * 文件位置: ActivityServiceImpl.java:202-236
 */
@Override
@Transactional(rollbackFor = Exception.class)
public void checkinActivity(Long activityId, CheckinRequest request) {
    Long userId = StpUtil.getLoginIdAsLong();

    // 验证活动是否存在
    Activity activity = this.getById(activityId);
    if (activity == null) {
        throw new BusinessException(20101, "活动不存在");
    }

    // 验证用户是否为该社团的负责人
    verifyClubLeader(activity.getClubId(), userId);

    // 验证操作类型
    if (!"check_in".equals(request.getAction()) && !"absent".equals(request.getAction())) {
        throw new BusinessException(20104, "无效的操作类型");
    }

    // 批量更新报名状态
    for (Long signupUserId : request.getUserIds()) {
        LambdaQueryWrapper<ActivitySignup> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(ActivitySignup::getActivityId, activityId)
                .eq(ActivitySignup::getUserId, signupUserId);
        ActivitySignup signup = activitySignupMapper.selectOne(wrapper);

        if (signup != null && signup.getStatus() == SignupStatus.REGISTERED) {
            if ("check_in".equals(request.getAction())) {
                signup.setStatus(SignupStatus.CHECKED_IN);
                signup.setCheckinTime(LocalDateTime.now());
            } else {
                signup.setStatus(SignupStatus.ABSENT);
            }
            activitySignupMapper.updateById(signup);
        }
    }
}
```

**技术要点**:
1. **权限验证**: 调用`verifyClubLeader()`确保只有社团负责人可以签到
2. **批量处理**: 支持一次性为多个用户签到,提升操作效率
3. **状态流转**: REGISTERED → CHECKED_IN/ABSENT,记录签到时间
4. **安全校验**: 只能对REGISTERED状态的报名记录进行签到操作



### 6.2.5 异步通知系统

代码位置

- **文件**: `NotificationServiceImpl.java:62-89`
- **功能**: 异步发送通知,支持多渠道(站内+邮件)

```java
/**
 * 发送通知(异步)
 * 文件位置: NotificationServiceImpl.java:62-89
 */
@Override
@Async("notificationExecutor")
public void sendNotification(Long userId, String title, String content,
                            NotificationType type, String relatedType, Long relatedId,
                            NotificationPriority priority) {
    try {
        // 获取用户通知设置
        UserNotificationSetting setting = getUserSetting(userId);

        // 检查是否启用该类型通知
        if (!isNotificationEnabled(setting, type)) {
            log.debug("用户已禁用该类型通知: userId={}, type={}", userId, type);
            return;
        }

        // 发送站内消息
        if (shouldSendInApp(setting, type)) {
            sendInAppNotification(userId, title, content, type, relatedType, relatedId, priority);
        }

        // 发送邮件
        if (shouldSendEmail(setting, type)) {
            sendEmailNotification(userId, title, content, type);
        }
    } catch (Exception e) {
        log.error("发送通知失败: userId={}, title={}", userId, title, e);
        // 不抛出异常,避免影响主业务流程
    }
}
```

**技术要点**:
1. **异步处理**: 使用`@Async`注解实现异步发送,不阻塞主业务流程
2. **多渠道策略**: 根据用户设置选择站内通知、邮件等不同渠道
3. **用户偏好**: 读取user_notification_setting表,尊重用户的通知偏好
4. **异常隔离**: catch异常不抛出,确保通知失败不影响主业务
