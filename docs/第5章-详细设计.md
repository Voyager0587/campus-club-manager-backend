# 第5章 详细设计

## 5.1 核心功能时序图

本系统选取了以下4个核心功能进行详细设计:

1. **用户登录与权限验证** - 展示Sa-Token认证授权流程
2. **社团申请与审核** - 展示完整的审批业务流程
3. **活动报名与签到** - 展示活动管理核心流程
4. **通知系统** - 展示异步消息通知机制

### 1.1 用户登录与权限验证流程

该功能展示了系统的认证授权机制,包括用户登录、Token生成和基于角色的权限验证。

```plantuml
@startuml 用户登录与权限验证
actor 用户
participant UserController
participant UserService
participant UserMapper
participant StpUtil
database MySQL

用户 -> UserController: POST /user/login\n{username, password}
activate UserController

UserController -> UserService: login(request)
activate UserService

UserService -> UserMapper: selectOne(username)
activate UserMapper
UserMapper -> MySQL: SELECT * FROM user\nWHERE username = ?
MySQL --> UserMapper: 用户数据
UserMapper --> UserService: User对象
deactivate UserMapper

UserService -> UserService: 验证密码\nencryptPassword(password)

alt 密码错误
    UserService --> UserController: 抛出BusinessException\n"用户名或密码错误"
    UserController --> 用户: 400 Bad Request
else 账户被禁用
    UserService --> UserController: 抛出BusinessException\n"账户已被禁用"
    UserController --> 用户: 400 Bad Request
else 登录成功
    UserService -> StpUtil: login(userId)
    activate StpUtil
    StpUtil -> StpUtil: 生成Token并存储会话
    StpUtil --> UserService: void
    deactivate StpUtil

    UserService -> StpUtil: getTokenValue()
    StpUtil --> UserService: token字符串

    UserService -> UserService: convertToUserInfoVO(user)
    UserService --> UserController: LoginResponse\n{token, userInfo}
    deactivate UserService

    UserController --> 用户: 200 OK\n{token, userInfo}
end

deactivate UserController

== 访问需要权限的接口 ==

用户 -> UserController: GET /user/info\nHeader: satoken=xxx
activate UserController

UserController -> StpUtil: @SaCheckRole("user")\n验证角色权限
activate StpUtil
StpUtil -> StpUtil: 检查token有效性
StpUtil -> StpUtil: 验证用户角色

alt 未登录或token无效
    StpUtil --> UserController: 抛出NotLoginException
    UserController --> 用户: 401 Unauthorized
else 角色权限不足
    StpUtil --> UserController: 抛出NotRoleException
    UserController --> 用户: 403 Forbidden
else 验证通过
    StpUtil --> UserController: 验证通过
    deactivate StpUtil

    UserController -> UserService: getCurrentUserInfo()
    activate UserService
    UserService -> StpUtil: getLoginIdAsLong()
    StpUtil --> UserService: userId
    UserService -> UserMapper: selectById(userId)
    UserMapper --> UserService: User对象
    UserService --> UserController: UserInfoVO
    deactivate UserService

    UserController --> 用户: 200 OK\n{userInfo}
end

deactivate UserController
@enduml
```

**流程说明**:
1. 用户提交用户名和密码
2. 系统验证用户名、密码和账户状态
3. 验证通过后,Sa-Token生成并返回Token
4. 后续请求携带Token访问需要权限的接口
5. `@SaCheckRole`注解自动验证用户角色

---

### 1.2 社团申请与审核流程

该功能展示了完整的业务审批流程,包括申请提交、状态管理、审核处理和通知发送。

```plantuml
@startuml 社团申请与审核
actor 学生
actor 管理员
participant ClubController
participant ClubService
participant ClubApplicationMapper
participant ClubMemberMapper
participant NotificationService
database MySQL

== 学生申请加入社团 ==

学生 -> ClubController: POST /club/apply\n{clubId, reason}
activate ClubController

ClubController -> ClubService: applyJoinClub(request)
activate ClubService

ClubService -> StpUtil: getLoginIdAsLong()
StpUtil --> ClubService: userId

ClubService -> ClubService: 检查社团是否存在
ClubService -> ClubService: 检查是否已是成员
ClubService -> ClubService: 检查是否有待审核申请

alt 已是成员
    ClubService --> ClubController: 抛出BusinessException\n"已是社团成员"
    ClubController --> 学生: 400 Bad Request
else 有待审核申请
    ClubService --> ClubController: 抛出BusinessException\n"已有待审核申请"
    ClubController --> 学生: 400 Bad Request
else 可以申请
    ClubService -> ClubApplicationMapper: insert(application)
    activate ClubApplicationMapper
    ClubApplicationMapper -> MySQL: INSERT INTO club_application\n(club_id, user_id, status, reason)
    MySQL --> ClubApplicationMapper: success
    ClubApplicationMapper --> ClubService: 申请ID
    deactivate ClubApplicationMapper

    ClubService -> NotificationService: 发送通知给管理员
    activate NotificationService
    NotificationService --> ClubService: void
    deactivate NotificationService

    ClubService --> ClubController: void
    deactivate ClubService

    ClubController --> 学生: 200 OK\n"申请已提交,请等待审核"
end

deactivate ClubController

== 管理员审核申请 ==

管理员 -> ClubController: POST /admin/club/applications/review\n{applicationId, approve, reviewNote}
activate ClubController

ClubController -> ClubService: reviewApplication(request)
activate ClubService

ClubService -> StpUtil: getLoginIdAsLong()
StpUtil --> ClubService: reviewerId

ClubService -> ClubApplicationMapper: selectById(applicationId)
activate ClubApplicationMapper
ClubApplicationMapper -> MySQL: SELECT * FROM club_application\nWHERE id = ?
MySQL --> ClubApplicationMapper: application数据
ClubApplicationMapper --> ClubService: ClubApplication对象
deactivate ClubApplicationMapper

ClubService -> ClubService: 检查申请状态\n(必须是PENDING)

alt 申请已处理
    ClubService --> ClubController: 抛出BusinessException\n"该申请已被处理"
    ClubController --> 管理员: 400 Bad Request
else 审核通过
    ClubService -> ClubApplicationMapper: updateById()\n设置status=APPROVED
    activate ClubApplicationMapper
    ClubApplicationMapper -> MySQL: UPDATE club_application\nSET status='APPROVED'
    MySQL --> ClubApplicationMapper: success
    ClubApplicationMapper --> ClubService: void
    deactivate ClubApplicationMapper

    ClubService -> ClubMemberMapper: insert(member)
    activate ClubMemberMapper
    ClubMemberMapper -> MySQL: INSERT INTO club_member\n(club_id, user_id, role)
    MySQL --> ClubMemberMapper: success
    ClubMemberMapper --> ClubService: void
    deactivate ClubMemberMapper

    ClubService -> NotificationService: 发送审核通过通知给申请人
    activate NotificationService
    NotificationService --> ClubService: void
    deactivate NotificationService

    ClubService --> ClubController: void
    ClubController --> 管理员: 200 OK\n"审核成功"
else 审核拒绝
    ClubService -> ClubApplicationMapper: updateById()\n设置status=REJECTED
    ClubApplicationMapper -> MySQL: UPDATE club_application\nSET status='REJECTED'
    MySQL --> ClubApplicationMapper: success
    ClubApplicationMapper --> ClubService: void

    ClubService -> NotificationService: 发送审核拒绝通知给申请人
    NotificationService --> ClubService: void
    deactivate NotificationService

    ClubService --> ClubController: void
    deactivate ClubService
    ClubController --> 管理员: 200 OK\n"审核成功"
end

deactivate ClubController
@enduml
```

**流程说明**:
1. 学生提交加入社团申请,状态为PENDING
2. 系统验证是否已是成员或有待审核申请
3. 管理员查看待审核申请列表
4. 管理员审核申请(通过/拒绝)
5. 审核通过自动添加为社团成员
6. 系统发送通知给申请人

---

### 1.3 活动报名与签到流程

该功能展示了活动管理的核心流程,包括报名验证、人数控制和签到管理。

```plantuml
@startuml 活动报名与签到
actor 学生
actor 社团负责人
participant ActivityController
participant ActivityService
participant ActivityMapper
participant ActivitySignupMapper
participant NotificationService
database MySQL

== 学生报名活动 ==

学生 -> ActivityController: POST /activity/{id}/signup
activate ActivityController

ActivityController -> ActivityService: signupActivity(activityId)
activate ActivityService

ActivityService -> StpUtil: getLoginIdAsLong()
StpUtil --> ActivityService: userId

ActivityService -> ActivityMapper: selectById(activityId)
activate ActivityMapper
ActivityMapper -> MySQL: SELECT * FROM activity\nWHERE id = ?
MySQL --> ActivityMapper: activity数据
ActivityMapper --> ActivityService: Activity对象
deactivate ActivityMapper

ActivityService -> ActivityService: 检查活动状态\n(必须是PUBLISHED)
ActivityService -> ActivityService: 检查报名时间\n(在报名时间范围内)
ActivityService -> ActivityService: 检查是否已报名
ActivityService -> ActivityService: 检查人数限制

alt 活动不可报名
    ActivityService --> ActivityController: 抛出BusinessException\n"活动未发布/已取消"
    ActivityController --> 学生: 400 Bad Request
else 不在报名时间内
    ActivityService --> ActivityController: 抛出BusinessException\n"不在报名时间内"
    ActivityController --> 学生: 400 Bad Request
else 已报名
    ActivityService --> ActivityController: 抛出BusinessException\n"已报名该活动"
    ActivityController --> 学生: 400 Bad Request
else 人数已满
    ActivityService --> ActivityController: 抛出BusinessException\n"报名人数已满"
    ActivityController --> 学生: 400 Bad Request
else 报名成功
    ActivityService -> ActivitySignupMapper: insert(signup)
    activate ActivitySignupMapper
    ActivitySignupMapper -> MySQL: INSERT INTO activity_signup\n(activity_id, user_id, status)
    MySQL --> ActivitySignupMapper: success
    ActivitySignupMapper --> ActivityService: void
    deactivate ActivitySignupMapper

    ActivityService -> ActivityMapper: updateById()\n增加current_members
    activate ActivityMapper
    ActivityMapper -> MySQL: UPDATE activity\nSET current_members = current_members + 1
    MySQL --> ActivityMapper: success
    ActivityMapper --> ActivityService: void
    deactivate ActivityMapper

    ActivityService -> NotificationService: 发送报名成功通知
    activate NotificationService
    NotificationService --> ActivityService: void
    deactivate NotificationService

    ActivityService --> ActivityController: void
    deactivate ActivityService

    ActivityController --> 学生: 200 OK\n"报名成功"
end

deactivate ActivityController

== 社团负责人签到 ==

社团负责人 -> ActivityController: POST /club-admin/activity/{id}/checkin\n{userIds, status}
activate ActivityController

ActivityController -> ActivityService: checkinActivity(activityId, request)
activate ActivityService

ActivityService -> StpUtil: getLoginIdAsLong()
StpUtil --> ActivityService: operatorId

ActivityService -> ActivityService: 验证操作权限\n(是否为社团负责人)

ActivityService -> ActivitySignupMapper: selectByActivityAndUsers()
activate ActivitySignupMapper
ActivitySignupMapper -> MySQL: SELECT * FROM activity_signup\nWHERE activity_id = ? AND user_id IN (?)
MySQL --> ActivitySignupMapper: signup列表
ActivitySignupMapper --> ActivityService: List<ActivitySignup>
deactivate ActivitySignupMapper

loop 遍历每个用户
    ActivityService -> ActivitySignupMapper: updateById()\n设置status和checkin_time
    activate ActivitySignupMapper
    ActivitySignupMapper -> MySQL: UPDATE activity_signup\nSET status=?, checkin_time=?
    MySQL --> ActivitySignupMapper: success
    ActivitySignupMapper --> ActivityService: void
    deactivate ActivitySignupMapper

    ActivityService -> NotificationService: 发送签到通知
    activate NotificationService
    NotificationService --> ActivityService: void
    deactivate NotificationService
end

ActivityService --> ActivityController: void
deactivate ActivityService

ActivityController --> 社团负责人: 200 OK\n"签到成功"
deactivate ActivityController
@enduml
```

**流程说明**:
1. 学生浏览活动列表并选择活动报名
2. 系统验证活动状态、报名时间和人数限制
3. 创建报名记录,更新活动当前报名人数
4. 活动开始时,社团负责人批量为用户签到
5. 支持标记缺席,记录签到时间

---

### 1.4 通知系统流程

该功能展示了系统的异步通知机制,支持多渠道(站内+邮件)和用户偏好设置。

```plantuml
@startuml 通知系统
participant 业务模块
participant NotificationService
participant NotificationMapper
participant UserNotificationSettingMapper
participant EmailService
database MySQL

== 发送通知流程 ==

业务模块 -> NotificationService: sendNotification(\nuserId, title, content, type, priority)
activate NotificationService

NotificationService -> UserNotificationSettingMapper: selectByUserId(userId)
activate UserNotificationSettingMapper
UserNotificationSettingMapper -> MySQL: SELECT * FROM user_notification_setting\nWHERE user_id = ?
MySQL --> UserNotificationSettingMapper: 用户通知设置
UserNotificationSettingMapper --> NotificationService: NotificationSetting
deactivate UserNotificationSettingMapper

NotificationService -> NotificationService: 根据用户设置判断\n是否启用该类型通知

alt 站内通知已启用
    NotificationService -> NotificationMapper: insert(notification)
    activate NotificationMapper
    NotificationMapper -> MySQL: INSERT INTO notification\n(user_id, title, content, type, priority)
    MySQL --> NotificationMapper: success
    NotificationMapper --> NotificationService: void
    deactivate NotificationMapper
end

alt 邮件通知已启用
    NotificationService -> EmailService: sendEmail(\nto, subject, content)
    activate EmailService
    EmailService -> EmailService: 构建邮件内容
    EmailService -> EmailService: 发送邮件
    EmailService --> NotificationService: void
    deactivate EmailService
end

NotificationService --> 业务模块: void
deactivate NotificationService

== 批量发送通知 ==

业务模块 -> NotificationService: sendBatchNotification(\nuserIds, title, content, type, priority)
activate NotificationService

loop 遍历每个用户
    NotificationService -> NotificationService: sendNotification(\nuserId, title, content, type, priority)

    note right
        异步处理,避免阻塞
        失败时记录日志,不影响其他用户
    end note
end

NotificationService --> 业务模块: void
deactivate NotificationService

== 用户查询通知 ==

actor 用户
participant NotificationController

用户 -> NotificationController: GET /notification/list\n?pageNum=1&pageSize=10&type=audit&readFlag=false
activate NotificationController

NotificationController -> StpUtil: getLoginIdAsString()
StpUtil --> NotificationController: userId

NotificationController -> NotificationService: getUserNotifications(\nuserId, pageNum, pageSize, type, readFlag)
activate NotificationService

NotificationService -> NotificationMapper: selectPage(queryWrapper)
activate NotificationMapper
NotificationMapper -> MySQL: SELECT * FROM notification\nWHERE user_id = ? AND type = ?\nAND read_flag = ?\nLIMIT ? OFFSET ?
MySQL --> NotificationMapper: 分页数据
NotificationMapper --> NotificationService: Page<Notification>
deactivate NotificationMapper

NotificationService -> NotificationService: 转换为VO对象
NotificationService --> NotificationController: Page<NotificationVO>
deactivate NotificationService

NotificationController --> 用户: 200 OK\n{notifications, total}
deactivate NotificationController

== 标记已读 ==

用户 -> NotificationController: PUT /notification/mark-read\n{notificationId: 123}
activate NotificationController

NotificationController -> StpUtil: getLoginIdAsString()
StpUtil --> NotificationController: userId

NotificationController -> NotificationService: markAsRead(notificationId, userId)
activate NotificationService

NotificationService -> NotificationMapper: selectById(notificationId)
activate NotificationMapper
NotificationMapper -> MySQL: SELECT * FROM notification\nWHERE id = ?
MySQL --> NotificationMapper: notification
NotificationMapper --> NotificationService: Notification
deactivate NotificationMapper

NotificationService -> NotificationService: 验证通知所有权

alt 通知不属于当前用户
    NotificationService --> NotificationController: 抛出BusinessException\n"无权操作"
    NotificationController --> 用户: 403 Forbidden
else 标记成功
    NotificationService -> NotificationMapper: updateById()\n设置read_flag=1, read_time=now
    activate NotificationMapper
    NotificationMapper -> MySQL: UPDATE notification\nSET read_flag = 1, read_time = ?
    MySQL --> NotificationMapper: success
    NotificationMapper --> NotificationService: void
    deactivate NotificationMapper

    NotificationService --> NotificationController: void
    deactivate NotificationService

    NotificationController --> 用户: 200 OK\n"操作成功"
end

deactivate NotificationController
@enduml
```

**流程说明**:
1. 业务模块触发通知发送(如审核通过)
2. 查询用户通知偏好设置
3. 根据设置选择渠道(站内/邮件)
4. 异步发送通知,不阻塞主业务
5. 用户查询通知列表,支持筛选
6. 用户标记已读,记录阅读时间

---

## 5.2 关键代码

详见独立文档: [5.2-关键代码.md](./5.2-关键代码.md)

包含以下5段核心代码及详细注释:
1. 用户登录与Sa-Token权限验证
2. 社团申请审核与事务管理
3. 活动报名与并发控制
4. 活动签到批量操作
5. 异步通知系统

---

## 5.3 系统部署图

本系统采用云原生架构,前后端分离部署在阿里云ECS服务器上,使用微信云托管MySQL作为数据库服务。

```plantuml
@startuml 系统部署图
!define ICONURL https://raw.githubusercontent.com/tupadr3/plantuml-icon-font-sprites/v2.4.0
skinparam componentStyle rectangle

' 定义节点样式
skinparam node {
    BackgroundColor lightblue
    BorderColor darkblue
    FontSize 12
}

skinparam component {
    BackgroundColor lightyellow
    BorderColor orange
    FontSize 11
}

skinparam database {
    BackgroundColor lightgreen
    BorderColor darkgreen
}

skinparam cloud {
    BackgroundColor lightcyan
    BorderColor darkblue
}

' 客户端层
actor "Web用户" as user

' 前端服务器
node "阿里云ECS #1\n(前端服务器)" as ecs1 {
    component "Nginx 1.24+\n(反向代理+静态资源)" as nginx
    component "Vue3前端应用\n(静态文件)" as vue

    nginx -down-> vue : 托管
}

' 后端服务器
node "阿里云ECS #2\n(后端服务器)" as ecs2 {
    component "JDK 21运行环境" as jdk
    component "Spring Boot 3.3.10\n(内嵌Tomcat 9)" as springboot

    jdk -down-> springboot : 运行

    package "应用层" {
        component "Controller层\n(API接口)" as controller
        component "Service层\n(业务逻辑)" as service
        component "Mapper层\n(数据访问)" as mapper
    }

    springboot -down-> controller
    controller -down-> service
    service -down-> mapper
}

' 数据库服务
cloud "微信云托管" as wechat_cloud {
    database "MySQL 8.0+\n(关系型数据库)" as mysql {
        frame "核心数据表" {
            [user] as user_table
            [club] as club_table
            [activity] as activity_table
            [notification] as notification_table
        }
    }
}

' 云存储服务
cloud "阿里云OSS" as aliyun_oss {
    component "对象存储服务\n(图片/文件)" as oss
    folder "存储桶" {
        [avatar/] as avatar_folder
        [cover/] as cover_folder
        [content/] as content_folder
    }
    oss -down-> avatar_folder
    oss -down-> cover_folder
    oss -down-> content_folder
}

' AI服务
cloud "阿里云AI服务" as aliyun_ai {
    component "通义千问API\n(智能问答)" as ai_api
}

' 邮件服务
cloud "SMTP邮件服务" as smtp {
    component "邮件服务器\n(通知发送)" as mail_server
}

' Redis缓存(可选)
node "阿里云Redis\n(缓存服务器)" as redis_node {
    database "Redis 7.0+\n(会话/缓存)" as redis {
        [Token缓存] as token_cache
        [权限缓存] as permission_cache
    }
}

' 连接关系 - 客户端到前端
user -right-> nginx : "HTTPS请求\n443端口"

' 前端到后端
nginx -down-> springboot : "反向代理\nHTTP/HTTPS\n8080端口"

' 后端到数据库
mapper -down-> mysql : "JDBC连接\nMyBatis Plus\n3306端口"

' 后端到Redis
service -right-> redis : "Sa-Token会话\nJedis客户端\n6379端口"

' 后端到OSS
service -down-> oss : "SDK上传\nHTTPS"

' 后端到AI服务
service -down-> ai_api : "REST API\nHTTPS"

' 后端到邮件服务
service -down-> mail_server : "SMTP协议\n465/587端口"

' 部署说明
note right of ecs1
  <b>前端服务器配置</b>
  - CPU: 2核
  - 内存: 4GB
  - 磁盘: 40GB SSD
  - 操作系统: Ubuntu 22.04 LTS
  - Nginx配置: Gzip压缩、缓存
end note

note right of ecs2
  <b>后端服务器配置</b>
  - CPU: 4核
  - 内存: 8GB
  - 磁盘: 100GB SSD
  - 操作系统: Ubuntu 22.04 LTS
  - JVM参数: -Xms2G -Xmx4G
end note

note bottom of mysql
  <b>数据库配置</b>
  - 规格: 2C4G
  - 存储: 100GB SSD
  - 字符集: utf8mb4
  - 时区: Asia/Shanghai
  - 备份策略: 每日全量备份
end note

note bottom of redis_node
  <b>缓存配置</b>
  - 规格: 2GB标准版
  - 持久化: RDB+AOF
  - 数据过期: LRU策略
  - 主从模式: 高可用
end note

@enduml
```

### 部署架构说明

#### 1. **前端部署(阿里云ECS #1)**
- **Web服务器**: Nginx 1.24+
  - 反向代理: 将API请求转发到后端服务器
  - 静态资源托管: 托管Vue3构建后的静态文件
  - Gzip压缩: 减少传输数据量
  - 浏览器缓存: 优化静态资源加载速度
  - HTTPS配置: SSL/TLS证书加密通信

- **前端应用**: Vue3 + Vite构建
  - 单页应用(SPA)架构
  - 代码分割和懒加载
  - 生产环境优化构建

#### 2. **后端部署(阿里云ECS #2)**
- **运行环境**: JDK 21 + Spring Boot 3.3.10
  - 内嵌Tomcat容器,默认8080端口
  - JVM优化参数配置
  - 健康检查端点

- **应用分层**:
  - Controller层: RESTful API接口
  - Service层: 业务逻辑处理
  - Mapper层: MyBatis Plus数据访问

- **进程管理**:
  - 使用systemd或PM2管理Java进程
  - 自动重启和日志管理
  - 优雅关闭机制

#### 3. **数据库服务(微信云托管MySQL)**
- **MySQL 8.0+**
  - 关系型数据库存储
  - 支持事务ACID特性
  - InnoDB存储引擎
  - 自动备份和恢复
  - 读写分离(可选)

#### 4. **缓存服务(阿里云Redis)**
- **Redis 7.0+**
  - Sa-Token会话存储
  - 权限信息缓存
  - 热点数据缓存
  - 分布式锁实现
  - 主从高可用架构

#### 5. **对象存储(阿里云OSS)**
- **文件存储服务**
  - 用户头像存储(avatar/)
  - 活动封面存储(cover/)
  - 富文本图片存储(content/)
  - CDN加速访问
  - 图片处理服务

#### 6. **第三方服务**
- **阿里云AI服务**: 提供智能问答功能
- **SMTP邮件服务**: 发送系统通知邮件
- **SSL证书服务**: HTTPS安全通信

#### 7. **网络配置**
- **安全组策略**:
  - 前端ECS: 开放80(HTTP)、443(HTTPS)端口
  - 后端ECS: 仅允许前端ECS访问8080端口
  - 数据库: 仅允许后端ECS访问3306端口
  - Redis: 仅允许后端ECS访问6379端口

- **负载均衡(可扩展)**:
  - 使用阿里云SLB实现多实例负载均衡
  - 支持水平扩展

#### 8. **部署流程**
1. **前端部署**:
   ```bash
   npm run build  # 本地构建
   scp -r dist/* user@ecs1:/var/www/html/  # 上传到服务器
   nginx -s reload  # 重载Nginx配置
   ```

2. **后端部署**:
   ```bash
   mvn clean package  # Maven打包
   scp target/*.jar user@ecs2:/app/  # 上传jar包
   systemctl restart campus-club-backend  # 重启服务
   ```

#### 9. **监控与运维**
- **日志管理**:
  - Nginx访问日志和错误日志
  - Spring Boot应用日志(Logback)
  - 日志轮转和归档

- **性能监控**:
  - 阿里云云监控
  - JVM性能指标
  - 数据库慢查询分析
  - Redis性能监控

- **备份策略**:
  - 数据库每日自动备份
  - 代码版本控制(Git)
  - 配置文件备份

---

## 设计亮点总结

### 1. 架构设计
- **分层清晰**: Controller-Service-Mapper三层架构,职责明确
- **面向接口**: Service层定义接口,利于扩展和测试
- **依赖注入**: 使用@RequiredArgsConstructor实现构造器注入

### 2. 事务管理
- **声明式事务**: @Transactional注解管理事务边界
- **原子性保证**: 多表操作在同一事务中,保证数据一致性
- **回滚策略**: rollbackFor = Exception.class确保异常回滚

### 3. 权限控制
- **Sa-Token集成**: 轻量级权限框架,自动管理会话
- **注解驱动**: @SaCheckRole实现声明式权限验证
- **细粒度控制**: 方法级权限验证,确保数据安全

### 4. 性能优化
- **异步处理**: 通知发送使用@Async,不阻塞主流程
- **冗余字段**: current_members避免频繁COUNT查询
- **批量操作**: 签到支持批量处理,减少数据库交互

### 5. 代码质量
- **异常处理**: 统一BusinessException,友好错误提示
- **参数校验**: @Valid注解实现参数自动验证
- **日志记录**: @Slf4j注解,关键操作记录日志
- **代码复用**: 公共方法提取,避免重复代码
